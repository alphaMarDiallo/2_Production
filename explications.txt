-------
SYMFONY
-------

INTRO : Qu'est-ce que Symfony ?
ETAPE 1 : Installation du framework Symfony 3.4 (version LTS - long term support - actuelle)
ETAPE 2 : Les bundles
ETAPE 3 : Les routes et les controllers (Routing : l'url d√©termine la classe instanci√©e et la m√©thode appel√©e)
ETAPE 4 : Cr√©er notre BoutiqueBundle
ETAPE 5 : TWIG - moteur de template
ETAPE 6 : Assets
ETAPE 7 : Les Entit√©s
ETAPE 8 : Doctrine
ETAPE 9 : Les formulaires
ETAPE 10 : La validation des donn√©es
ETAPE 11 : S√©curit√© et Utilisateurs
ETAPE 12 : Les services
ETAPE 13 : Les √©v√®nements
ETAPE 14 : Symfony 4 (BundleLess et Flex)

-------------------


-----------------------------------------------------
-- INTRO : Qu'est-ce que Symfony ?                 --
-----------------------------------------------------

1- Avantages √† utiliser un framework du march√© ?
    A- Offre une organisation optimis√©e
    B- Fonctionnalit√©s communes d'un projet √† un autre
    C- Les services disponibles (on r√©cup√®re des services d√©ja cod√©s : routing, s√©curit√©, twig, doctrine...)
    D- La communaut√©

2- Choix du framework ?
    A- Construire son propre framework ?
    B- Les framework fullstack (Symfony, Laravel, Zend, Cake...) ?
    C- Les mini-frameworks (Silex, Slim, fat-free, Lumen) ?

3- Symfony :
    A- Framework fran√ßais cr√©√© par les √©quipes de SensioLab (agence Web)
    B- Versions :
        LTS :
            - 2.8
            - 3.4 (2.8 moins quelques fonctionnalit√©s d√©pr√©ci√©es)
        4 / 4.1 / 4.2 :
            -> minimum PHP 7.1
            -> Bundle-less
            -> Flex (Service qui configure les outils de mani√®re automatique et standardis√©e)


-----------------------------------------------------
-- ETAPE 1 : Installation du framework Symfony 3.4 --
-----------------------------------------------------
Sommaire :
1- installer composer
2- installer une application SF (Symfony) vierge
3- arborescence des dossiers et fichiers de SF
4- lancement de l'application
5- Fonctionnement des URL
-------------------
1- installer composer
    - Composer est un outil de gestion de d√©pendances.
    - Il permet d'installer les services (composants ou d√©pendances ou services sont synonymes) et de les
    mettre √† jour. Equivalent de NPM pour le JS.
    - Il est reli√© √† un fichier composer.json

2- installer une application SF (Symfony) vierge
    A- se diriger sur le dossier o√π on installe SF
    <cmd>
    cd c://Xampp/htdocs/Symfony

    Ou
    dans le dossier cible click droit + maj > ouvrir une fen√™tre power-shell

    B- installer un projet SF
    avec symfony installer :
    <cmd>
    symfony new project nom-du-projet

    Ou
    avec Composer
    <cmd>
    composer create-project symfony/framework-standard-edition projet-test
    framework-standard-edition inclus tous les services
    skeleton-version optimis√©e pour le web (celle que l'on prendrait en prod, pas en formation)

    C- valider sans renseigner les infos de connexion √† la BDD (pour l'instant, sera diff√©rent sur un projet prod)

3- arborescence des dossiers/fichiers
    - app/ : la configuration de notre application + layout
    - bin/ : ex√©cutables de notre app (interactions avec la console par exemple)
    - src/ : contient tout le code de notre application. C'est ici que l'on √©crira notre code
    - tests/ : concerne tous les tests de notre application
    - var/ : concerne les fichiers √©cris par SF au cours du processus d'ex√©cution (cache, les logs...)
    - vendor/ : contient tout le code-source d'un projet SF
    - web/ : contient tous les fichiers accessibles aux clients (internaute/navigateur) c'est-√†-dire :
                img/ (design du site)
                photo/ (avatars upload√©s...)
                JS/
                fonts/
                CSS/
                et le fichier controller frontal (app.php ou app_dev.php) qui correspond √† l'index.php
    - composer.json : contient les d√©pendances. Ce fichier permet de mettre √† jour l'application et les d√©pendances.
     Avant m√™me de commencer √† coder, nous constatons simplement qu'il est bien rempli...

4- Lancement de notre application
    M√©thode 1 :
    Navigateur : localhost/Symfony/projet-test/web/app.php
    Navigateur : localhost/Symfony/projet-test/web/app_dev.php
    Virtual Host √† configurer dans xampp : dev.boutique.com ---> localhost/Symfony/projet-test/web/app_dev.php

    M√©thode 2 :
    Serveur interne √† SF
    <cmd>
    cd projet_test
    php bin/console server:run
    puis dans le navigateur : localhost:8000
    (si j'ai plusieurs projets Symfony le second sera sur le port 8001, on peut m√™me les d√©finir)
    nous permet de ne pas avoir √† con figurer des virtual hosts pour nosprojets

    Les fichiers exc√©ut√©s sont web/app.php (mode prod)
    web/app_dev.php (mode dev)

    test :
    localhost/Symfony/projet-test/web/app.php/page_inconnue
    localhost/Symfony/projet-test/web/app_dev.php/page_inconnue
    localhost:8000/page_inconnue

    En prod les erreurs sont invisibles (page 404) alors qu'en dev on a une page avec les erreurs. En dev on a une barre de d√©veloppeur

5- Fonctionnement des URL

    Nos controllers frontaux (app.php ou app_dev.php c√†d index.php de SF) re√ßoivent une requ√™te HTTP (URL) et demandent √† un composant
    de SF - le Kernel - de charger un controller et une fonction
    Pour que le Kernel s'y retrouve on va cr√©er des routes

    Voir le fichier src/AppBundle/Controller/DefaultController.php


-----------------------------------------------------
-- ETAPE 2 : Les bundles                           --
-----------------------------------------------------
Sommaire :
1- le concept de bundle
2- Cr√©ation de notre bundle-less

--------
1- le concept de bundle
    - brique de l'application
        ex  - ProduitBundle :
                        Controller/
                            boutiqueAction() : affichage de la home ou page boutique
                            categorieAction() : affichage des produits d'une cat√©gorie
                            produitAction() : affichage d'un produit
            - MembreBundle :
                        Controller/
                            inscriptionAction()
                            connexionAction()
                            ...

            - BaseBundle :
                        Controller/
                            homeAction()
                            contactAction()
                            cgvAction()

        ‚ö°Ô∏èAvec le temps on estime plus propre de faire un AppBundle avec tous les controllers dedans ‚ö°Ô∏è

    - un bundle se compose de :
            - Controller/ : les controllers du Bundle (fichiers dans lesquels on va cr√©er les routes)
                    - MembreController
                    - ProduitController
                    - BaseController
            - DependencyInjection/ : infos du Bundle
            - Entity/ : contient les classes Mod√®les (POPO : Plain Old PHP Object) (classes Mod√®les =/= classe standard StdClass de PHP)
            - Form/ : contient les formulaires de notre application
            - Ressources/ : contiendra 3 dossiers :
                    - Public/ : JS, CSS
                    - Config/ : fichiers de configuration du Bundle (routing...)
                    - Views/ : toutes les vues de l'application (.html.twig)
            - Repository/ : contient les repository du Bundle


-------------------
2- Cr√©ation de notre Bundle-less
<cmd>
php bin/console generate:bundle

    - on choisit un nom au Bundle (avec ou sans Namespace) :
        => are you planning on sharing this bundle across multiple applications? [no]:
        (en clair => mon Bundle appartient-il √† un namespace) => si je mets yes on indique le nom du namespace
         (par convention celui de l'entreprise), puis le nom du Bundle (ici on tape juste sur entr√©e)

         POLES\TestBundle (POLES:namespace)

    - on choisit la destination [src/]
    - on choisit le format des config [xml] : annotation

    ‚ùÑÔ∏è Enregistrer le Bundle dans composer.json [PSR-4] :

        => le terminal nous indique qu'il reste des op√©rations √† effectuer manuellement : √©diter le composer.json (cf ligne ‚öúÔ∏è):
               "autoload": {
                    "psr-4": {
                        "AppBundle\\": "src/AppBundle",
               ‚öúÔ∏è    "POLES\\": "src/POLES"
                    },

    ‚ùÑÔ∏è On met l'application √† jour
    <cmd>
    composer update

    ‚ùÑÔ∏èATTENTION : dans cette version de SF, par d√©faut la fonction render appelle les vues de mauvaise mani√®re
        -> POLESTestBundle:Default:index.html.twig  √† modifier pour :
        -> @POLESTest/default/index.html.twig

    üêæ A ce stade, notre home doit afficher 'Hello world!'
    üêæ Notre application et notre nouveau Bundle sont op√©rationnels


-----------------------------------------------------
-- ETAPE 3 : Les routes et les controllers         --
-----------------------------------------------------
Sommaire :
1- Cr√©ation de route
2- L'objet Request
3- L'objet Response
4- Redirection
-------------------------
1- Cr√©ation de route
    -> route ("/") : route simple rend une vue "hello world!"
    -> route("/bonjour") : route sans param√®tre et sans vue (juste un echo)
    -> route("/bonjour2") : route sans param√®tre et avec Response
    -> route("/hello/{prenom}") : route avec param√®tre et avec Response
    -> route("/hola/{prenom}") : route avec param√®tre et avec rendu d'une vue html.twig
    -> route("/hi/{prenom}") : route avec param√®tre d'URL + param√®tre GET (age) et avec rendu d'une vue html.twig
    -> route("/redirect") : route avec redirection (2 fa√ßons de faire)
    -> route("/message}") : route avec utilisation de la session $_SESSION

 - les routes sont d√©clar√©es soit en annotation, soit en XML, soit en PHP, soit en YML (ici on a choisit en annotation)
 - chaque route est li√©e √† une fonction (action) qui contient Action dans son nom comme suffixe
 - lors de la cr√©ation d'une route on peut d√©finir un param√®tre dynamique/variable avec les {}. Celui-ci sera r√©cup√©r√© en argument de la fonction

    üêæ Une requ√™te HTTP est toujours constitu√©e d'une REQUETE et d'une REPONSE
--------------------------

2- L'objet Request

L'objet request stocke les informations de la requ√™t HTTP

<code>
use Symfony\Component\HttpFoundation\Request;

exemples d'usages :
‚ùÑÔ∏èget au sens 'rapporte' et non $_GET

$request->query->get('parametre_en_get');
$request->request->get('parametre_en_post');
$request->cookies->get('parametre_en_cookie');
$request->server->get('parametre_du_serveur');
$request->attributes->get('parametre_en_url');

www.boutique.com/bonjour/mila?age=12
www.boutique.com/bonjour/{prenom}?age=12
$request->request->get('age');
$request->attributes->get('prenom');

Si request cherche un param√®tre qui n'existe pas, il retourne une r√©ponse vide et non une erreur


Pour r√©cup√©rer/enregistrer des infos en session :

M√©thode 1 :
$session = $request->getSession();
$session->get('id_membre');
$session->set('id_membre', 12);

M√©thode 2 :
$request->session->get('id_membre');
$request->session->set('id_membre', 12);


--------------------------
3- L'objet Response

- l'objet Response va permettre √† nos routes de retourner une r√©ponse. Chaque route doit au final retourner une r√©ponse.

<code>
use Symfony\Component\HttpFoundation\Response;

La fonction render() qui affiche une vue c'est d√©j√† une r√©ponse. render() appartient √† l'objet Response

$this->render('vue.html.twig');
$this->getTemplating()->renderResponse('vue.html.twig');

--------------------------
4- Redirection

<code>
use Symfony\Component\HttpFoundation\RedirectResponse;

(voir la route /redirect)
A ce stade, les routes doivent avoir un nom. Ce nom va servir pour les redirections, mais √©galement pour les liens href

--------------------------
5- Message

La variable "app" utilis√©e dans les templates Twig (message.html.twig).
C'est une variable globale qui contient des informations g√©n√©rales sur l'application (app.session, app.user)

üå∏ üå∏ üå∏
   üå∏ üå∏ üå∏

-----------------------------------------------------
-- ETAPE 4 : Cr√©er notre BoutiqueBundle            --
-----------------------------------------------------
Sommaire :
1- cr√©er un nouveau projet Symfony (Boutique3 -> 3 pour SF 3)
2- cr√©er et enregistrer notre BoutiqueBundle
3- update de l'app
4- r√©organiser le bundle (controller et vues)
5- cr√©er les premi√®res routes

----------------------------------
1- cr√©er un nouveau projet Symfony (Boutique3 -> 3 pour SF 3)

- se placer dans le dossier Symfony
- lancer la console
<cmd>
composer create-project symfony/framework-standard-edition Boutique3

----------------------------------
2- cr√©er et enregistrer notre BoutiqueBundle

- se placer dans le projet Boutique3
<cmd>
cd Boutique3

- cr√©er le bundle
<cmd>
php bin/console generate:bundle
N
BoutiqueBundle
src/
annotation

- enregistrer le bundle
<code> compopser.json
"psr-4": {
    "AppBundle\\": "scr/AppBundle",
    "BoutiqueBundle\\": "src/BoutiqueBundle"
    },

<cmd>
composer update

- lancement du serveur
<cmd>
php bin/console server:run

- Modification de render dans la m√©thode indexAction de src/BoutiqueBundle/Controller/DefaultController
<code>
render('@Boutique/Default/index.html.twig');

TEST : localhost:8000

----------------------------------
3- update de l'app

 - Apr√®s avoir enregistr√© notre BoutiqueBundle, on modifie le fichier composer.json et on met √† jour l'application
    -> dans app/config/routing.yml le routing est ajout√©
    -> dans app/appKernel.php le bundle est enregistr√©

----------------------------------
4- r√©organiser le bundle (controller et vues)

    -> rennomer le fichier DefaultController.php en ProduitController.php
    -> dans les vues on a ajout√© :
        Produit/, Commande/, Membre

----------------------------------
5- cr√©er les premi√®res routes

    ProduitController :
        -> "/" -> indexAction() -> index.html.twig
        -> "/produit/{id}" -> produitAction() -> produit.html.twig
        -> "/categorie/{cat}" -> categorieAction() -> index.html.twig

    üêæ A ce stade, les vues n'ont pas de design, nous allons mettre cela en place dans le prochian cha^pitre Twig
    üêæ A ce stade, nous ne pouvons pas encore communiquer avec la BDD, il faut voir Doctrine (sujet vaste) pour cela.
       On cr√©√© donc dans nos controllers des donn√©es fictives en attendant

-----------------------------------------------------
-- ETAPE 5 : TWIG - moteur de template             --
-----------------------------------------------------
Sommaire :
1- Qu'est-ce que Twig ?
2- Cr√©er un layout
3- L'h√©ritage Twig
4- Modification de nos vues
5- Documentation Twig

-------------------------------------
1- Qu'est-ce que Twig ?

    - Twig est un moteur de template dont l'objectif est de simplifier le pr√©sence de PHP dans l'HTML
      Mais aussi de faciliter certaines action (boucle, mettre un texte en majuscules, formater les dates...)
      Autres moteurs : TPL, Smarty, Liquid etc...

    - Twig est issu de Symfony, mais on peut √©galement l'installer sur tout projet

-------------------------------------
2- Cr√©er un layout

    - un layout, c'est la structure d'une page du site. Un site peut avoir plusieurs structures de page (home, produit, admin, mentions l√©gales...)

    - un layout estpr√™t √† re√ßevoir des vues (blocs HTML)  en d√©clarant des 'block'
        -> r√©cup√©r√© le haut et le bas du site boutique fait en proc√©dural
        -> on nomme le fichier layout.html.twig
        -> on l'enregistre dans Boutique3/app/Resources/views/ (r√©pertoire pour les layouts jusqu'√† SF 3)
        -> dans le layout on cr√©√© un block content
        -> nos vues h√©ritent du ou d'un layout

-------------------------------------
3- L'h√©ritage Twig

    - Au m√™me titre que l'h√©ritage en PHP, Twig permet de dire √† un fichier qu'il d√©pend d'un parent
    - pour Twig en r√©alit√©, l'h√©ritage se mat√©rialise par le fait de cr√©er des blocs dans le parent (fen√™tres ouvertes)
      dans lesquelles les vues peuvent afficher ou non du contenu HTML

     ‚ö°Ô∏èsi une vue h√©rite d'un template, il ne peut pas y avoir de contenu en dehors d'un block d√©clar√© ‚ö°Ô∏è

-------------------------------------
4- Modification de nos vues

    -> index.html.twig :
        - on r√©cup√®re le code HTML correspondant au projet proc√©dural boutique.php
        - on d√©finit l'h√©ritage
        - on met le contenu de boutique.php dans le block content
        - on √©crit les boucles en Twig :
            <?php foreach($produits as $produit) ?> -- PHP natif ‚òòÔ∏è
            {{ for produit in produits }}
        - on √©crit les variables en Twig :
            <?php echo $produit['titre]'?> -- proc√©dural ‚òòÔ∏è
            <?= $produit->getTitre() ?> -- objet ‚òòÔ∏è
            {{ produit.titre }}

-------------------------------------
5- Documentation Twig

https://twig.symfony.com/doc/2.x/

-------------------------------------
-- EXERCICE                        --
-------------------------------------
    - afficher la page 'categorie/tshirt'
        -> r√©cup√©rer les arrays cr√©√©s dans la route index
        -> passer toutes les infos √† la vue via render ($params)
        -> tester : localhost:8000/categorie/fff

    - afficher la page d'un produit '/produit/12'
        -> cr√©er un array avec les infos d'un produit
        -> passer les infos de ce produit √† la vue
        -> cr√©er la vue produit.html.twig
            -> h√©ritage Twig
            -> HTML √† r√©cup√©rer dans la boutique faite en proc√©dural
            -> variables √† changer (PHP => TWIG)
        -> tester localhost:8000/produit/12


-----------------------------------------------------
-- ETAPE 6 : Assets                                --
-----------------------------------------------------
Sommaire :
1- Modification du composer.json
2- Mise √† jour de l'application
3- Modification de nos vues
---------------------------------------

Le composant Asset de Symfony nous permet de g√©rer les ressources (images, photos, CSS, JS, liens etc...) et de les appeler de mani√®re absolue

1- Modification du composer.json

    <code>
    "require:" {
        "symfony/asset": "^3.4"
        },

---------------------------------------
2- Mise √† jour de l'application

    <cmd>
    composer update
    -> le composer prend connaissance du composer.json, et met √† jour les composants d√©j√† install√©s et/ou ajoute les composants pas encore install√©s

    Autre m√©thode :
    <cmd>
    composer require symfony/asset
    -> le composer installe le composant demand√© et met √† jour le fichier composer.json

---------------------------------------
3- Modification de nos vues

    - layout
        -> href="../../../web/css/style.css"
           href="{{ asset('css/style.css') }}"

           La fonction asset de twig permet d'avoir le chemin absolu vers le dossier web (fait tout seul comme __racine_server__)

        -> href="index.php"
           href="{{ path('home') }}"

           La fonction path de twig permet d'afficher le chemin absolu d'une route. On utilise le nom (name="" dans l'annonation) de la route dans la fonction

    - vues
        -> src="../../../web/photo/<?php $produit['photo'] ?>""
           src="{{ asset('/photo/' ~ produit.photo )"

           La fonction asset permet de d√©finir un chemin dynamique

        -> href="fiche_produit.php?id=<?php produit['id_produit'] ?>"
           href="{{ path('produit', {'id': produit.id_produit}) }}"

           La fonction path permet de d√©finir des url dynamiques o√π :
                - 'produit' = nom de la route
                - 'id' = le nom du param√®tre dynamique attendu dans la route
                - produit.id_produit = la valeur du param√®tre


-----------------------------------------------------
-- ETAPE 7 : Les Entit√©s                           --
-----------------------------------------------------
Sommaire :
1- Doctrine ORM et le concept d'entity
2- Cr√©er entit√© Produit
3- Annotations
4- Mettre √† jour la BDD depuis les entit√©s
5- G√©n√©rer une entity en ligne de commande
6- G√©n√©rer les entit√©s Membre et Commande depuis la BDD
7- Cr√©er la BDD depuis les entit√©s

-----------------------------------------------------
1- Doctrine ORM et le concept d'entity

    - D'une certaine mani√®re les entit√©s correspondent √† la partie MODEL de notre MVC. C'est la relation avec la BDD
    - Normalement, on ne devrait plus faire de SQL, ni ouvrir PHPMyAdmin
    - On cr√©√© des entity (Classes, plan de fabrication de nos objets, POPO) qui vont permettre √† DOCTRINE de manipuler les tables dans la BDD
    -Par exemple, nous ne ferons plus de requ√™te INSERT, mais on utilisera une fonction de doctrine (persist()) qui sera en mesure √† travers nos Entity de manipuler la BDD

    -> Pour que tout cela soit possible, il faut d√©finir les int√©ractions existantes entre nos Entity et la BDD, via DOCTRINE ORM (Object Relation Mapping). On parle de mapping.

-----------------------------------------------------
2- Cr√©er entit√© Produit

    1- cr√©er un dossier Entity/ dans notre BoutiqueBundle
    2- g√©n√©rer les entit√©s depuis la BDD
    3- cr√©er les propri√©t√©s, les getter/setter et le mapping


-----------------------------------------------------
3- Annotations

<code>
use Doctrine\ORM\Mapping as ORM;

    /**
    * @ORM\Table
    * @ORM\Entity
    */
    On pr√©cise que cette entit√© est mapp√©e, et la table √† laquelle elle correspond

    Pour chaque propri√©t√© on d√©finit les infos :
        - cl√© primaire
            /**
            * @ORM\Column
            * @ORM\Id
            * @ORM\GeneratedValue ...
            */

        - autre propri√©t√©s
            /**
            * @ORM\Column
            */

    Liens :
        basic mapping : https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html

        association mapping : https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html#association-mapping


        modifier app/config/parameters.yml
            parameters:
            ‚òòÔ∏èdatabase_host: localhost
            ‚òòÔ∏èdatabase_port: 3306 // sur MAC 8889
            ‚òòÔ∏èdatabase_name: site_commerce
                 database_user: root
                 database_password: null
                 mailer_transport: smtp
                 mailer_host: 127.0.0.1
                 mailer_user: null
                 mailer_password: null
                 secret: ThisTokenIsNotSoSecretChangeIt


-----------------------------------------------------
4- Mettre √† jour la BDD depuis les entit√©s

<cmd>
php bin/console doctrine:schema:update --dump-sql
-> montrer la equ√™te √† ex√©cuter

R√©sultat :

ALTER TABLE produit MODIFY id_produit INT NOT NULL;
DROP INDEX id_produit ON produit;
ALTER TABLE produit DROP PRIMARY KEY;
ALTER TABLE produit CHANGE titre titre VARCHAR(20) NOT NULL, CHANGE photo photo
VARCHAR(250) DEFAULT NULL, CHANGE id_produit id INT AUTO_INCREMENT NOT NULL;
ALTER TABLE produit ADD PRIMARY KEY (id);

<cmd>
php bin/console doctrine:schema:update --force
-> ex√©cute la requ√™te SQL (modif de la BDD)

-----------------------------------------------------
5- G√©n√©rer une entity en ligne de commande

<cmd>
php bin/console doctrine:generate:entity

puis on suit les diff√©rentes indications / √©tapes
ex : The Entity shortcut name:
    -> BoutiqueBundle:Membre


-----------------------------------------------------
6- G√©n√©rer les entities depuis la BDD

    1- supprimons le dossier Entity pour tout recr√©er (ici on a renomm√© Entity_ comme cela le syst√®me ne le conna√Æt plus)
    2- <cmd>
    php bin/console doctrine:mapping:import BoutiqueBundle\Entity annotation --path=src/BoutiqueBundle/Entity
        -> cela cr√©√© les entit√©s sans getter et setter

    3- <cmd>
    php bin/console doctrine:generate:entities BoutiqueBundle
        -> cela met √† jour les entit√©s avec les getter et setter

        pour aller plus loin voir :
             php bin/console doctrine:generate:entities BoutiqueBundle
             NOTE: The doctrine:generate:entities command has been deprecated.
                   To read more about the differences between anemic and rich models go here
             http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/tutorials/gett
            ing-started.html#adding-behavior-to-entities.
                   If you wish to generate your entities, use make:entity --regenerate from
            MakerBundle instead.

    4- Je vais lier mes entit√©s √† un reporsitory
    @ORM\Entity(repositoryClass="BoutiqueBundle\Repository\ProduitRepository)
    @ORM\Entity(repositoryClass="BoutiqueBundle\Repository\MembreRepository)
    @ORM\Entity(repositoryClass="BoutiqueBundle\Repository\CommandeRepository)
    @ORM\Entity(repositoryClass="BoutiqueBundle\Repository\DetailsCommandeRepository)

    <cmd>
    php bin/console doctrine:generate:entities BoutiqueBundle
    -> cela va cr√©er les repository correspondant √† nos entit√©s


-----------------------------------------------------
7- Cr√©er la BDD depuis les entit√©s

    1-> pour tester ce dernier point, √† savoir la cr√©ation de la BDD depuis les Entit√©s existantes, on va modifier les param√®tres de connexion √† la BDD. On se
    connecte √† un site_boutique2 qui n'existe pas
    <code> app/conf/parameters.yml
        database_name: site_commerce2


    2-> <cmd>
    php bin/console doctrine:database:generate

    3-> <cmd>
    php bin/console doctrine:schema:update --dump-sql
    -> montrer la equ√™te √† ex√©cuter

    4-> <cmd>
    php bin/console doctrine:schema:update --force
    -> ex√©cute la requ√™te SQL (modif de la BDD)


-----------------------------------------------------
-- ETAPE 8 : Doctrine                              --
-----------------------------------------------------
Sommaire :
1- le service Doctrine
2- Acc√©der au service Doctrine depuis les controllers
3- Requ√™te "SELECT * FROM ..."
4- Requ√™te "SELECT * FROM ... WHERE id = x"
5- Requ√™te "SELECT * FROM ... WHERE c = d"
6- Requ√™te INSERT/UPDATE
7- Requ√™te DELETE
8- Create Query et le Query Builder

-----------------------------------------------------
1- le service Doctrine - DQL (Doctrine Query Language)
    -> Doctrine est un outil puissant qui est utilis√© dans Symfony mais √©galement dans ZEND, Laravel, Cake ...

    -> Doctrine se compose de 2 √©l√©ments :
        - ORM (Object Relation Mapping) : Mapping des entit√©s
        - DBAL (Database Abstract Layer) : L'id√©e est de simplifier les requ√™tes SQL en utilisant des fonctions PHP.
          On parle de DQL (Doctrine Query Language). DBAL va remplacer PDO en fait.

Rappel : Un repository est un mod√®le (objet) qui permet d'acc√©der et de manipuler une table de la BDD


-----------------------------------------------------
2- Acc√©der au service Doctrine depuis les controllers

    -> soit via l'EntityRepository :
    <code> dans un controller :
    $repository = $this->getDoctrine()->getRepository(Produit::class);

    -> soit via l'EntityManager
    <code> dans un controller
    $em = $this->getDoctrine()->getManager();

    <code> dans un Repository
    $em = $this->getEntityManager();

    Dans le controller on choisit le manager ou le repository en fonction de ce dont on a vraiment besoin.


-----------------------------------------------------
3- Requ√™te "SELECT * FROM ..."

    <code>
    $produits = $repository->findAll();

-----------------------------------------------------
4- Requ√™te "SELECT * FROM ... WHERE id = x"

    <code>
    $produit = $repository->find($id);
    $produit = $em->find(Produit::class, $id);

-----------------------------------------------------
5- Requ√™te "SELECT * FROM ... WHERE c = d"

    <code>
    $produits = $repository->findBy(['categorie' => $cat);

    $etudiant = $repository->findOneBy(['John']);
    => retourne le 1er r√©sultat trouv√©

    => on peut enchainer plusieurs requ√™tes (tous les tshirts rouges tri√©s du plus au moins cher, limit√© aux 10 premiers r√©sultats)
    $rpoduits = $repository->findBy(['categorie' => 'tshirt', 'couleur' => 'rouge'], ['prix' => 'DESC'], 10, 0];

-----------------------------------------------------
6- Requ√™te INSERT/UPDATE

    INSERT
    - Pour ins√©rer un enregistrement, on instacie un objet de la classe (Entity) correspondante, on affecte des valeurs aux propri√©t√©s
    (via un formulaire - pour l'exemple on a commenc√© en dur)
    $produit = new Produit;
    $produit -> setReference('xx')->setCategorie('blabla') etc...

    - puis  on persist() l'objet
    $em->persist();

    - enfin on l'enregistre
    $em->flush();

    UPDATE
    - pour modifier un enregistrement, d'abord on le r√©cup√®re sous forme d'objet (find), on le modifie (via un formulaire),
    puis on le persist() et on flush()
    cf. la route /admin/produit/update/{id}


-----------------------------------------------------
7- Requ√™te DELETE

    - pour supprimer un enregistrement, d'abord on le r√©cup√®re sous forme d'objet (find)
    on pr√©pare la suppression de cet objet remove() et enfin on flush()
    cf. la route /admin/produit/delete/{id}

-----------------------------------------------------
8- Create Query et le Query Builder

    Doctrine nous permet de manipuler simplement les enregistrements dans la BDD (ORM), √† travers l'utilisation des objets (Entity)
    et de fonctions simples (findAll, find, findBy, findOneBy, persist, remove, flush)

    - cela dit on pourrait √™tre amen√©s √† vouloir des requ√™tes plus complexes et plus sp√©cifiques. Doctrine nous fournit deux outils pour le faire :
        => createQuery() :
            permet d'√©crire du SQL (du DQL en fait)
            -> cf. route 'home'

        => queryBuilder() :
            permet d'√©crire du SQL en PHP OO
            -> cf. route 'home' ou ProduitRepository

    Liens :
        Doc Doctrine :
            https://www.doctrine-project.org/

        CreateQuery :
            https://hotexamples.com/examples/doctrine.orm/EntityManager/createQuery/php-entitymanager-createquery-method-examples.html

        QueryBuilder :
            https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html
            https://www.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/reference/query-builder-api.html#creating-a-query-builder (modifi√©)

        Find :



----------------------
EXERCICES :
----------------------

- Cr√©er un controller AdminController
- Cr√©er les routes (sous forme de liste dans un 1er temps)
	-> show_produits
	(affiche tous les produits dans un tableau)
	-> delete_produit
	(supprime un produit via son ID et retourne √† show_produit)

	-> show_commandes
	(affiche toutes les commandes dans un tableau)
	-> delete_commande
	(supprime une commande via son ID et retourne √† show_commandes)

	-> show_membres
	(affiche tous les membres dans un tableau)
	-> delete_membre
	(supprime un membre via son ID et retourne √† show_membres)

- G√©rer les affichages des pages correspondantes :
	-> fonction render
	-> layout_admin.html.twig ou  layout.html.twig
	-> dossier admin dans les views
	-> les vues corespondantes
		- show_produits.html.twig
		- show_commandes.html.twig
		- show_membres.html.twig

- R√©cup√©rer les infos en BDD dans les routes
- Effectuer les traitements dans les routes


-----------------------------------------------------
-- ETAPE 9 : Les formulaires                       --
-----------------------------------------------------
Boutique3/app/config/config.yml
Boutique3/app/Resources/views/layout.html.twig
		=> liens inscription / connexion

Boutique3/src/BoutiqueBundle/
		Controller/
			AdminController.php
			MembreController.php
			ProduitController.php
		Entity/
			Commande.php
			DetailCommande.php
			Membre.php
			Produit.php
		Form/ (new)
			CommandeType.php (new)
			MembreType.php (new)
			ProduitType.php (new)
		Repository/
			CommandeRepository.php
			DetailCommandeRepository.php
			MembreRepository.php
			ProduitRepository.php
		Resources/views
			Membre.php
			Produit.php
			admin.php

Boutique3/web/
	css/
		style.css
	photo/
		(toutes)
	app_dev.php

Boutique3
	composer.json
	composer.lock
=====================SOURCE ALPHA 26 nov 2018=================================================
... liens √† v√©rif ...
Lines :
	Doc Doctrine :
	  https://www.doctrine-project.org/

	CreatQuery :    https://hotexamples.com/examples/doctrine.orm/EntityManager/createQuery/php-entitymanager-createquery-method-examples.html

	QueryBuilder :
	https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html

	QueryBuilder :
	 https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html

    https://www.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/reference/query-builder-api.html#creating-a-query-builder
======================================================================

...................
... 26/11/2018 ...
... FORMULAIRES ...
...................

----------------------------------
ETAPE  9 : Les formulaires
----------------------------------

Sommaire :
1/ Le fonctionnement des formulaire
2/ Cr√©ation d'une formulaire simple pour l'inscription
3/ Les classes types
4/ R√©cup√©rer les donn√©es du formulaire
5/ Personnaliser le formulaire avec bootstrap
6/ Cr√©er nos propres class type h√©rit√© de AbstractType
7/ Update un enregistrement tr√®s simplement
8/ Champs File (pour la photo d'un produit par exemple)
-------------------------------

1/ Le fonctionnement des formulaire

Avec Symfony, nos formulaires sont li√©s  √† une entit√©
	-> inscription -> Entity/Membre
	-> ajout de produit -> Entity/Produit
	-> lmodification de produit -> Entity/Produit

	Par exemple lorsque l'on modifie un produit en BDD via un formulaire... En r√©alit√© le formulaire modifie un objet produit, on dit que l'on hydrate le formulaire.

	Chaque type de champs (text, checkbox, select, submit...) correspond √† une classe (textType, checkboxType, ChoiceType, SubmitType...).


2/ Cr√©ation d'une formulaire simple pour l'inscription
	-> Cr√©er une route "/inscription" dans le MembreController

	FormBuilder est un constructeur de formulaire. Il nous permet de param√®trer un formulaire.

	Methode long :
	$formBuilder = $this->get('form.factory')->createBuilder(FormType::class, $membre);
	M√©thode courte :
	$formBuilder = $this->createBuilder($membre);

	En cr√©ant un formulaire on le lie √† un objet issu d'une entit√© ($membre).

	On param√®tre le formulaire(cr√©er chaque champs) gr√¢ce √† la m√©thode add de notre formBuilder.
	$formBuilder->add('prenom', textType::class) etc...

	/!\ Attention √† bien use toutes les classes Type dont nous avons besoin


	On oublie pas de g√©n√©rer le formulaire :
	$form = $formBuilder->getForm();

	Enfin on r√©cup√®re la view :
	'membreForm' = $Form->createView();

	Dans le Twig le formulaire est afficher de plusieur mani√®re possible (voir inscription.html.twig)
	{{form'membreForm}}

3/ Les classes types

lien :
	https://symfony.com/doc/current/reference/forms/types.html


4/ R√©cup√©rer les donn√©es du formulaire

	a/ On r√©cup√®re la requete POST du formulaire et on lie les champs √† notre objet(hydrate l'objet)
		$form-> handleRequest($request);

		B/ On check que le formulaire soit bien activ√© (nom vide) et les donn√©es valides
			if($form->isSubmitted() && $form->valid()){}

			/!\ nous verrons plus bas les options de validit√©s

		C/ On enregistreles donn√©es saisies
		<code>
			$em = $this->getDoctrine()->getManager();
			$em->persist($membre);
			$em->flush();

- M√©thode 1 :
    fichier app/config/config.yml
    <code>
    twig
        form-themes:
            - 'bootstrap_4_layout.html.twig'



-M√©thode 2 :
	On prend la main sur la cr√©ation du formulaire avec notre propre structure et mise en forme voire le fichier form.html.twig
	<code>
	form_star() etc...

6/ Cr√©er nos propres class type h√©rit√© de AbstractType
	->Contexte : Actuellement pour ajouter un formulaire a une route, on r√©cup√®re le formBuilder et on configure tous les champs...
		-> probleme : les routes inscription, update_profil, admin_add_membre et admin_update_membre auront toutes besoin d'un m√™me formulaire...

		-> solution : On va cr√©er une classe MembreType dont le boulot sera de param√®trer(cr√©er) un formulaire Membre.

		-> R√©sultat : Il suffira de faire appel √† cette classe pour g√©n√©rer un formulaireMembre.

		==> GAIN DE TEMPS et meilleur FACTORISATION du code

		Comme souvent Symfony nous permet d'optimiser certaine chose via les ligne de commande.
		<code>
		php bin/console generate:doctrine:form BoutiqueBundle:Membre
		php bin/console generate:doctrine:form BoutiqueBundle:Produit
		php bin/console generate:doctrine:form BoutiqueBundle:Commande

7/ Update un enregistrement tr√®s simplement
8/ Champs File (pour la photo d'un produit par exemple)

===============FIN ALPHA 26 nov 2018========================================


-----------------------------------------------------
-- ETAPE 10 : La validation des donn√©es            --
-----------------------------------------------------



-----------------------------------------------------
-- ETAPE 11 : S√©curit√© et Utilisateurs             --
-----------------------------------------------------



-----------------------------------------------------
-- ETAPE 12 : Les services                         --
-----------------------------------------------------



-----------------------------------------------------
-- ETAPE 13 : Les √©v√®nements                       --
-----------------------------------------------------



-----------------------------------------------------
-- ETAPE 14 : Symfony 4 (BundleLess et Flex)       --
-----------------------------------------------------




-----------------------------------------------------
-- ETAPE 15 : MISE EN PROD                         --
-----------------------------------------------------

- SSH
- acc√©l√©rateur de cache









